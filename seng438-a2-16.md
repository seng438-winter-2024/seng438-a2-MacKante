**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      | 16                        |
| -------------- | ------------------------- |
| Student Names: | Dominic Choi              |
|                | Angelo Jerome T. Reynante |
|                | Nathan Ante               |
|                | Karam Baroud              |

# 1. Introduction

This lab introduces of understanding Junit, Unit testing, and Black Box Testing and familarize with Testing tools and Real life systems like Eclipse and JFreeChart.

Our group is meant to design, develop, and implement unit tests for JFreeChart, a Java framework for chart calculation, creation, and display. Specifically, we write tests for 2 classes: Range and DataUtilities. First, we start by designing the test cases, dividing them into Equivalence Class Partitions and their boundaries, and also identifying edge cases for robustness testing. We then write unit tests to examine the state and behavior of the methods and find faults in the program.

In this lab, our group is meant to perform over 10 methods for both Range

Our initial knowledge of unit testing and BlackBox testing came from content covered in lectures, but also from ENSF 380, a 2nd year software engineering course which offered a brief introduction into unit testing with JUnit. The lectures explained that unit testing is a focused kind of testing, which is meant to test a single "unit" of the overall system at a time. This allows developers to find faults which are isolated to those units and correct them. BlackBox testing involves multiple strategies, namely Equivalence Class Partitioning, Boundary Value Testing, Robustness Testing, and Worst Case Testing. This lab also introduced us to mocking, allowing us to create mocked responses of external methods and classes in order to observe the behavior and state of the SUT.

# 2. Scope 

All testing will be done with black box techniques in mind. Techniques like boundary value analysis and equivalence partitioning.

We will be testing 5 out of 15 methods from org.jfree.data.Range and all 5 from org.jfree.data.DataUtilities. More specifically...

## DataUtilities
### static double calculateColumnTotal(Values2D data, int column)
Returns the sum of the values in one column of the supplied data table.

### static double calculateRowTotal(Values2D data, int row)
Returns the sum of the values in one row of the supplied data table.

### static java.lang.Number[] createNumberArray(double[] data)
Constructs an array of Number objects from an array of double primitives.

### static java.lang.Number[][] createNumberArray2D(double[][] data)
Constructs an array of arrays of Number objects from a corresponding structure containing double primitives.

### static KeyedValues getCumulativePercentages(KeyedValues data)
Returns a KeyedValues instance that contains the cumulative percentage values for the data in another KeyedValues instance.

## Range (5 of 15)
### boolean	contains(double value)
Returns true if the specified value is within the range and false otherwise.

### double	getCentralValue()
Returns the central (or median) value for the range.

### double	getLength()
Returns the length of the range.

### double	getLowerBound()
Returns the lower bound for the range.

### double	getUpperBound()
Returns the upper bound for the range.

# 3. Detailed description of unit test strategy

###### A detailed description of the testing strategy for unit testing and your test-case design approach, i.e., how you used the black-box test-case design techniques equivalence classes, and boundary value analysis. Also list the name of the test cases you have designed and identify which one covers which parts of the strategy (which partition, which class, etc.) Include a discussion about what you feel are the benefits and drawbacks about using mocking.

Our group has primarily focused on implementing black-box testing, where we design test cases based on the behaviour of the methods without looking into their internal workings. We identified equivalence classes and applied boundary value analysis to ensure comprehensive coverage of tests for both Range class and DataUtilities class.

We identified different equivalence classes based on different scenarios and inputs for each method. For our tests, we identified equivalence classes such as zero range, null range, positive/negative range boundaries, values on/around range boundaries, etc. For boundary value analysis, we considered values near the edges of the input domain for each method. Some of the boundary values we identified were values like zero, values around the upper/lower bound in range, etc.
    
// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

    ✓☑✅︎

# 4. How the team work/effort was divided and managed

We read through the document and we divided the work for designing and creating test cases on both Range and DataUtilities. Here's how the methods to test were divided amongst group members:

Person 1: Nathan
- Range: getLowerBound
- Range: contains
- DataUtilities: createNumberArray2D

Person 2: Karam
- Range: getUpperBound
- DataUtilities: calculateColumnTotal
- DataUtilities: getCumulativePercentages

Person 3: Angelo
- Range: getCentralValue 
- DataUtilities: calculateRowTotal

Person 4: Dominic
- Range: getLength
- DataUtilities: createNumberArray

Each person was responsible for designing and implementing their unit tests. Once we all finished, we came together to combine our unit tests, ensuring they worked seamlessly together. 

# 5. Difficulties encountered, challenges overcome, and lessons learned

Troubles were had when setting up and using the Eclipse IDE for Java. None of us had much experience with it so we had to get accustomed to it and learn how to use the software and troubleshoot issues we came across.

Another issue encountered was thinking of good test cases for each method. Certain methods may be more difficult to test for different reasons such as mocking, and therefore require a more thoughtful approach to testing.

# 6. Comments/feedback on the lab itself

We believe the lab was an excellent introduction into Unit Testing with Java and Black Box testing, as well as a good way to start getting aquainted to JMock. 
